package mrtjp.projectred.expansion.client;

import codechicken.lib.render.CCModel;
import codechicken.lib.render.CCRenderState;
import codechicken.lib.render.lighting.LightModel;
import codechicken.lib.render.model.OBJParser;
import codechicken.lib.vec.Translation;
import codechicken.lib.vec.Vertex5;
import codechicken.lib.vec.uv.IconTransformation;
import net.minecraft.client.renderer.texture.TextureAtlas;
import net.minecraft.client.renderer.texture.TextureAtlasSprite;
import net.minecraft.resources.ResourceLocation;
import net.minecraftforge.client.event.TextureStitchEvent;
import net.minecraftforge.fml.loading.FMLEnvironment;

import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;

import static mrtjp.projectred.expansion.ProjectRedExpansion.MOD_ID;

@SuppressWarnings("NotNullFieldNotInitialized")
public class FrameModelRenderer {

    private static final Map<String, CCModel> frameModels = loadModels("frame");

    private static final CCModel[] models = new CCModel[64];
    private static IconTransformation frameIcon;

    public static TextureAtlasSprite getFrameIcon() {
        return frameIcon.icon;
    }

    public static void renderStatic(CCRenderState ccrs, int mask) {
        CCModel m = getOrGenerateModel(mask);
        m.render(ccrs, frameIcon);
    }

    public static Vertex5[] getQuadsForMask(int mask) {
        return getOrGenerateModel(mask).verts;
    }

    public static void onTextureStitchEvent(TextureStitchEvent.Post event) {
        if (!event.getAtlas().location().equals(TextureAtlas.LOCATION_BLOCKS)) return;
        frameIcon = new IconTransformation(event.getAtlas().getSprite(new ResourceLocation(MOD_ID, "block/frame")));
    }

    private static Map<String, CCModel> loadModels(String path) {
        ResourceLocation rl = new ResourceLocation(MOD_ID, "obj/" + path + ".obj");
        Map<String, CCModel> models = new OBJParser(rl)
                .ignoreMtl()
                .quads()
                .parse();
        models.replaceAll((k, v) -> v.backfacedCopy());

        for (Map.Entry<String, CCModel> m : models.entrySet()) {
            m.getValue().apply(new Translation(0.5, 0, 0.5));
            m.getValue().computeNormals();
            m.getValue().shrinkUVs(0.0005);
            m.getValue().computeLighting(LightModel.standardLightModel);
        }

        // Generate a static class with vertex array for server to use
        // Note: Temporary until OBJParser is made server-safe
        if (!FMLEnvironment.production) {
            try {

                String className = path.substring(0, 1).toUpperCase() + path.substring(1) + "ModelVerts";

                String filePath = "./" + MOD_ID + "/" + className + ".java";
                Files.createDirectories(Paths.get(filePath).getParent());

                try(FileWriter writer = new FileWriter(filePath)) {

                    writer.write("package mrtjp.projectred.expansion.client;\n\n");
                    writer.write("import codechicken.lib.vec.Vertex5;\n\n");
                    writer.write("import java.util.HashMap;\n");
                    writer.write("import java.util.Map;\n\n");

                    writer.write("/**\n");
                    writer.write(" * Generated by FrameModelRenderer.java. DO NOT EDIT\n");
                    writer.write(" *   Resource: " + rl + "\n");
                    writer.write(" */\n");
                    writer.write("public class " + className + " {\n\n");
                    writer.write("    public static final Map<String, Vertex5[]> verts = new HashMap<>();\n\n");

                    writer.write("    static {\n");
                    for (Map.Entry<String, CCModel> m : models.entrySet()) {
                        writer.write("        verts.put(\"" + m.getKey() + "\", new Vertex5[] {\n");
                        for (Vertex5 vert : m.getValue().verts) {
                            writer.write("            new Vertex5(" + vert.vec.x + ", " + vert.vec.y + ", " + vert.vec.z + ", " + vert.uv.u + ", " + vert.uv.v + "),\n");
                        }
                        writer.write("        });\n\n");
                    }
                    writer.write("    }\n\n");

                    writer.write("}\n");
                    writer.flush();
                }

            } catch (IOException e) {
                e.printStackTrace();
            }

        }

        return models;
    }

    private static CCModel getOrGenerateModel(int mask) {
        CCModel m = models[mask & 0x3F];
        if (m == null) {
            m = generateModel(mask);
            models[mask & 0x3F] = m;
        }
        return m;
    }

    private static CCModel generateModel(int mask) {
        List<CCModel> m = new LinkedList<>();
        m.add(frameModels.get("frame"));
        for (int i = 0; i < 6; i++) {
            if ((mask & (1 << i)) == 0) {
                m.add(frameModels.get("cross_" + i));
            }
        }

        return Objects.requireNonNull(CCModel.combine(m));
    }
}
